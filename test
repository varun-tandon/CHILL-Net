 "def embed_new_node(model, new_node_edge_index):\n",
    "    new_node_degree = new_node_edge_index.shape[1]\n",
    "    # get the number of nodes in the graph\n",
    "    new_node = LightGCN.num_nodes + 1\n",
    "    new_edges = new_node_edge_index\n",
    "\n",
    "    embedding_model = model.embedding\n",
    "    # get all edges corresponding to the random items\n",
    "    item_edges = train_graph.edge_index[:, torch.any(train_graph.edge_index[1].unsqueeze(1) == random_items, dim=1)]\n",
    "\n",
    "    # get the degree of each item\n",
    "    item_degrees = item_edges[1].unique(return_counts=True)\n",
    "    # get the random_items that do not have an edge\n",
    "    no_edge_items = random_items[~torch.any(random_items.unsqueeze(1) == item_degrees[0], dim=1)]\n",
    "    # drop the items in new_edges that do not have an edge\n",
    "    new_edges = new_edges[:, torch.any(new_edges[1].unsqueeze(1) == item_degrees[0], dim=1)]\n",
    "\n",
    "    item_degrees = item_degrees[1]\n",
    "    item_degrees = torch.sqrt(1 / (item_degrees * new_node_degree))\n",
    "\n",
    "    # get the embeddings of the random items\n",
    "    item_embeddings = embedding_model(new_edges[1].to(device))\n",
    "    item_degrees = torch.stack([item_degrees] * EMBEDDING_DIM, dim=1).to(device)\n",
    "    layer_embeddings = (item_degrees * item_embeddings).sum(dim=0)\n",
    "    return layer_embeddings"